const h="neil-rogers-soundboard-v2",a="neil-rogers-sounds-v2",u="neil-rogers-api-v2",g=["/","/index.html","/main.js","/manifest.json","/icons/icon-192x192.png","/icons/icon-512x512.png"];self.addEventListener("install",e=>{console.log("Service Worker: Installing..."),e.waitUntil(caches.open(h).then(o=>(console.log("Service Worker: Caching core files"),o.addAll(g))).then(()=>(console.log("Service Worker: Core files cached"),self.skipWaiting())).catch(o=>{console.error("Service Worker: Failed to cache core files",o)}))});self.addEventListener("activate",e=>{console.log("Service Worker: Activating..."),e.waitUntil(caches.keys().then(o=>Promise.all(o.map(n=>{if(n!==h&&n!==a&&n!==u)return console.log("Service Worker: Deleting old cache",n),caches.delete(n)}))).then(()=>(console.log("Service Worker: Activated"),self.clients.claim())))});self.addEventListener("fetch",e=>{console.log("🔍 SW Fetch intercepted:",e.request.url)},{capture:!0});self.addEventListener("fetch",e=>{const o=new URL(e.request.url);console.log("Service Worker: Intercepting request",o.pathname),o.pathname.startsWith("/sounds/")?(console.log("Service Worker: Handling audio request",o.pathname),e.respondWith(k(e.request))):o.pathname.startsWith("/api/")?(console.log("Service Worker: Handling API request",o.pathname),e.respondWith(w(e.request))):(console.log("Service Worker: Handling app shell request",o.pathname),e.respondWith(S(e.request)))});async function k(e){console.log("Service Worker: handleAudioRequest called for",e.url);const o=await caches.open(a),n=await o.match(e);if(n)return console.log("Service Worker: ✅ Serving cached audio",e.url),n;try{console.log("Service Worker: 🌐 Fetching audio from network",e.url);const c=await fetch(e);return c.ok?(console.log("Service Worker: 💾 Caching audio file",e.url),await o.put(e,c.clone()),console.log("Service Worker: ✅ Audio file cached successfully",e.url),self.clients.matchAll().then(t=>{t.forEach(i=>{i.postMessage({type:"AUDIO_CACHED",url:e.url})})})):console.error("Service Worker: ❌ Network response not ok",e.url,c.status),c}catch(c){return console.error("Service Worker: 💥 Audio file not available",e.url,c),new Response("Audio file not available offline",{status:404,statusText:"Not Found"})}}async function w(e){const o=await caches.open(u);try{const n=await fetch(e);return n.ok&&o.put(e,n.clone()),n}catch{console.log("Service Worker: Network failed for API, trying cache",e.url);const c=await o.match(e);return c||new Response(JSON.stringify({files:[]}),{headers:{"Content-Type":"application/json"}})}}async function S(e){const o=await caches.open(h),n=await o.match(e);if(n)return W(e,o),n;try{const c=await fetch(e);return c.ok&&o.put(e,c.clone()),c}catch{return e.destination==="document"?o.match("/index.html"):new Response("Resource not available offline",{status:404,statusText:"Not Found"})}}async function W(e,o){try{const n=await fetch(e);n.ok&&o.put(e,n.clone())}catch{console.log("Service Worker: Background update failed for",e.url)}}self.addEventListener("sync",e=>{e.tag==="update-sounds"&&e.waitUntil(p())});async function p(){try{console.log("Service Worker: Updating sounds cache...");const e=await fetch("/api/sounds.json");if(!e.ok)throw new Error("Failed to fetch sounds data");const o=await e.json(),n=o.files||o;await(await caches.open(u)).put("/api/sounds.json",e.clone());const t=await caches.open(a),f=(await t.keys()).map(s=>s.url),d=n.filter(s=>{const r=new URL(s.mp3,self.location.origin).href;return!f.includes(r)});if(d.length>0){console.log(`Service Worker: Caching ${d.length} new sounds...`);const s=d.slice(0,50);for(const r of s)try{const l=await fetch(r.mp3);l.ok&&await t.put(r.mp3,l)}catch(l){console.error("Service Worker: Failed to cache sound",r.mp3,l)}console.log("Service Worker: New sounds cached successfully")}}catch(e){console.error("Service Worker: Failed to update sounds cache",e)}}self.addEventListener("message",e=>{e.data&&e.data.type==="CACHE_SOUNDS"?e.waitUntil(A(e.data.sounds)):e.data&&e.data.type==="CACHE_AUDIO"&&e.waitUntil(v(e.data.url))});async function v(e){try{const o=await caches.open(a),n=await fetch(e);n.ok&&(await o.put(e,n),console.log("Service Worker: Cached audio file",e),self.clients.matchAll().then(c=>{c.forEach(t=>{t.postMessage({type:"AUDIO_CACHED",url:e})})}))}catch(o){console.error("Service Worker: Failed to cache audio file",e,o)}}async function A(e){const o=await caches.open(a);for(const n of e)try{const c=await fetch(n.mp3);c.ok&&(await o.put(n.mp3,c),self.clients.matchAll().then(t=>{t.forEach(i=>{i.postMessage({type:"AUDIO_CACHED",url:n.mp3})})}))}catch(c){console.error("Service Worker: Failed to cache sound",n.mp3,c)}}self.addEventListener("periodicsync",e=>{e.tag==="update-sounds-periodic"&&e.waitUntil(p())});
