const d="neil-rogers-soundboard-v2",i="neil-rogers-sounds-v2",u="neil-rogers-api-v2",g=["/","/index.html","/main.js","/manifest.json","/icons/icon-192x192.png","/icons/icon-512x512.png"];self.addEventListener("install",e=>{console.log("Service Worker: Installing..."),e.waitUntil(caches.open(d).then(n=>(console.log("Service Worker: Caching core files"),n.addAll(g))).then(()=>(console.log("Service Worker: Core files cached"),self.skipWaiting())).catch(n=>{console.error("Service Worker: Failed to cache core files",n)}))});self.addEventListener("activate",e=>{console.log("Service Worker: Activating..."),e.waitUntil(caches.keys().then(n=>Promise.all(n.map(o=>{if(o!==d&&o!==i&&o!==u)return console.log("Service Worker: Deleting old cache",o),caches.delete(o)}))).then(()=>(console.log("Service Worker: Activated"),self.clients.claim())))});self.addEventListener("fetch",e=>{console.log("🔍 SW Fetch intercepted:",e.request.url)},{capture:!0});self.addEventListener("fetch",e=>{const n=new URL(e.request.url);console.log("Service Worker: Intercepting request",n.pathname),n.pathname==="/manifest.json"?(console.log("Service Worker: Handling manifest request"),e.respondWith(k(e.request))):n.pathname.startsWith("/sounds/")?(console.log("Service Worker: Handling audio request",n.pathname),e.respondWith(m(e.request))):n.pathname.startsWith("/api/")?(console.log("Service Worker: Handling API request",n.pathname),e.respondWith(y(e.request))):(console.log("Service Worker: Handling app shell request",n.pathname),e.respondWith(w(e.request)))});async function k(e){try{const n=await self.clients.matchAll();let o=null;for(const a of n)try{const c=await fetch("/config.json");if(c.ok){o=await c.json();break}}catch(c){console.log("Config fetch failed:",c)}o||(o={title:"Soundboard PWA",shortName:"Soundboard",description:"A Progressive Web App soundboard",themeColor:"#1a1a1a",backgroundColor:"#1a1a1a"});const s={name:o.title,short_name:o.shortName||o.title.split(" ")[0],description:o.description,start_url:"/",display:"standalone",background_color:o.backgroundColor||o.themeColor,theme_color:o.themeColor,orientation:"portrait-primary",scope:"/",icons:[{src:"/icons/icon-72x72.png",sizes:"72x72",type:"image/png",purpose:"maskable any"},{src:"/icons/icon-96x96.png",sizes:"96x96",type:"image/png",purpose:"maskable any"},{src:"/icons/icon-128x128.png",sizes:"128x128",type:"image/png",purpose:"maskable any"},{src:"/icons/icon-144x144.png",sizes:"144x144",type:"image/png",purpose:"maskable any"},{src:"/icons/icon-152x152.png",sizes:"152x152",type:"image/png",purpose:"maskable any"},{src:"/icons/icon-192x192.png",sizes:"192x192",type:"image/png",purpose:"maskable any"},{src:"/icons/icon-384x384.png",sizes:"384x384",type:"image/png",purpose:"maskable any"},{src:"/icons/icon-512x512.png",sizes:"512x512",type:"image/png",purpose:"maskable any"}]};return console.log("Service Worker: Generated dynamic manifest for",o.title),new Response(JSON.stringify(s,null,2),{headers:{"Content-Type":"application/json","Cache-Control":"no-cache"}})}catch(n){return console.error("Service Worker: Error handling manifest request",n),fetch("/manifest.json")}}async function m(e){console.log("Service Worker: handleAudioRequest called for",e.url);const n=await caches.open(i),o=await n.match(e);if(o)return console.log("Service Worker: ✅ Serving cached audio",e.url),o;try{console.log("Service Worker: 🌐 Fetching audio from network",e.url);const s=await fetch(e);return s.ok?(console.log("Service Worker: 💾 Caching audio file",e.url),await n.put(e,s.clone()),console.log("Service Worker: ✅ Audio file cached successfully",e.url),self.clients.matchAll().then(a=>{a.forEach(c=>{c.postMessage({type:"AUDIO_CACHED",url:e.url})})})):console.error("Service Worker: ❌ Network response not ok",e.url,s.status),s}catch(s){return console.error("Service Worker: 💥 Audio file not available",e.url,s),new Response("Audio file not available offline",{status:404,statusText:"Not Found"})}}async function y(e){const n=await caches.open(u);try{const o=await fetch(e);return o.ok&&n.put(e,o.clone()),o}catch{console.log("Service Worker: Network failed for API, trying cache",e.url);const s=await n.match(e);return s||new Response(JSON.stringify({files:[]}),{headers:{"Content-Type":"application/json"}})}}async function w(e){const n=await caches.open(d),o=await n.match(e);if(o)return S(e,n),o;try{const s=await fetch(e);return s.ok&&n.put(e,s.clone()),s}catch{return e.destination==="document"?n.match("/index.html"):new Response("Resource not available offline",{status:404,statusText:"Not Found"})}}async function S(e,n){try{const o=await fetch(e);o.ok&&n.put(e,o.clone())}catch{console.log("Service Worker: Background update failed for",e.url)}}self.addEventListener("sync",e=>{e.tag==="update-sounds"&&e.waitUntil(h())});async function h(){try{console.log("Service Worker: Updating sounds cache...");const e=await fetch("/api/sounds.json");if(!e.ok)throw new Error("Failed to fetch sounds data");const n=await e.json(),o=n.files||n;await(await caches.open(u)).put("/api/sounds.json",e.clone());const a=await caches.open(i),f=(await a.keys()).map(r=>r.url),p=o.filter(r=>{const t=new URL(r.mp3,self.location.origin).href;return!f.includes(t)});if(p.length>0){console.log(`Service Worker: Caching ${p.length} new sounds...`);const r=p.slice(0,50);for(const t of r)try{const l=await fetch(t.mp3);l.ok&&await a.put(t.mp3,l)}catch(l){console.error("Service Worker: Failed to cache sound",t.mp3,l)}console.log("Service Worker: New sounds cached successfully")}}catch(e){console.error("Service Worker: Failed to update sounds cache",e)}}self.addEventListener("message",e=>{e.data&&e.data.type==="CACHE_SOUNDS"?e.waitUntil(C(e.data.sounds)):e.data&&e.data.type==="CACHE_AUDIO"&&e.waitUntil(W(e.data.url))});async function W(e){try{const n=await caches.open(i),o=await fetch(e);o.ok&&(await n.put(e,o),console.log("Service Worker: Cached audio file",e),self.clients.matchAll().then(s=>{s.forEach(a=>{a.postMessage({type:"AUDIO_CACHED",url:e})})}))}catch(n){console.error("Service Worker: Failed to cache audio file",e,n)}}async function C(e){const n=await caches.open(i);for(const o of e)try{const s=await fetch(o.mp3);s.ok&&(await n.put(o.mp3,s),self.clients.matchAll().then(a=>{a.forEach(c=>{c.postMessage({type:"AUDIO_CACHED",url:o.mp3})})}))}catch(s){console.error("Service Worker: Failed to cache sound",o.mp3,s)}}self.addEventListener("periodicsync",e=>{e.tag==="update-sounds-periodic"&&e.waitUntil(h())});
